//! Chat command - interactive chat with a model.

use anyhow::Result;
use clap::Args;
use colored::Colorize;
use dialoguer::{theme::ColorfulTheme, Input};

/// Chat command arguments.
#[derive(Args, Debug)]
pub struct ChatArgs {
    /// Model path or HuggingFace repo ID.
    #[arg(short, long, env = "RUSTEEZE_MODEL")]
    pub model: String,

    /// System prompt.
    #[arg(long)]
    pub system: Option<String>,

    /// Maximum tokens to generate per turn.
    #[arg(long, default_value = "512")]
    pub max_tokens: usize,

    /// Temperature for sampling.
    #[arg(long, default_value = "0.7")]
    pub temperature: f32,

    /// Top-p (nucleus sampling).
    #[arg(long, default_value = "0.9")]
    pub top_p: f32,

    /// Device (auto, cpu, cuda, metal).
    #[arg(long, default_value = "auto")]
    pub device: String,

    /// Chat template (llama, mistral, chatml, etc.).
    #[arg(long)]
    pub chat_template: Option<String>,

    /// Save conversation to file.
    #[arg(long)]
    pub save: Option<String>,
}

/// Chat history entry.
#[derive(Debug)]
struct ChatEntry {
    role: String,
    content: String,
}

/// Execute the chat command.
pub async fn execute(args: ChatArgs, _config_path: Option<String>) -> Result<()> {
    println!(
        "\n{} with {}",
        "Starting chat".bright_green().bold(),
        args.model.bright_cyan()
    );
    println!("Type {} to exit, {} to clear history\n", "/quit".bright_yellow(), "/clear".bright_yellow());

    let mut history: Vec<ChatEntry> = Vec::new();

    // Add system prompt if provided
    if let Some(ref system) = args.system {
        history.push(ChatEntry {
            role: "system".to_string(),
            content: system.clone(),
        });
        println!("{}: {}\n", "System".bright_magenta(), system);
    }

    let theme = ColorfulTheme::default();

    loop {
        // Get user input
        let input: String = match Input::with_theme(&theme)
            .with_prompt("You")
            .allow_empty(false)
            .interact_text()
        {
            Ok(i) => i,
            Err(_) => break,
        };

        // Handle commands
        if input.trim() == "/quit" || input.trim() == "/exit" {
            println!("\n{}", "Goodbye!".bright_green());
            break;
        }

        if input.trim() == "/clear" {
            history.clear();
            if let Some(ref system) = args.system {
                history.push(ChatEntry {
                    role: "system".to_string(),
                    content: system.clone(),
                });
            }
            println!("{}\n", "History cleared.".bright_yellow());
            continue;
        }

        if input.trim() == "/history" {
            println!("\n{}", "Chat History:".bright_cyan().bold());
            for entry in &history {
                println!("{}: {}", entry.role.bright_yellow(), entry.content);
            }
            println!();
            continue;
        }

        if input.trim() == "/help" {
            print_help();
            continue;
        }

        // Add user message to history
        history.push(ChatEntry {
            role: "user".to_string(),
            content: input.clone(),
        });

        // Generate response
        print!("\n{}: ", "Assistant".bright_green());
        std::io::Write::flush(&mut std::io::stdout())?;

        // Note: Actual generation would happen here
        // For now, simulate streaming response
        let response = "[This is a simulated response. In production, this would be generated by the model.]";

        for c in response.chars() {
            print!("{}", c);
            std::io::Write::flush(&mut std::io::stdout())?;
            tokio::time::sleep(tokio::time::Duration::from_millis(15)).await;
        }
        println!("\n");

        // Add assistant message to history
        history.push(ChatEntry {
            role: "assistant".to_string(),
            content: response.to_string(),
        });
    }

    // Save conversation if requested
    if let Some(ref save_path) = args.save {
        save_conversation(&history, save_path)?;
        println!("{} {}", "Conversation saved to".white(), save_path.bright_cyan());
    }

    Ok(())
}

/// Print help.
fn print_help() {
    println!("\n{}", "Available Commands:".bright_cyan().bold());
    println!("  {} - Exit the chat", "/quit".bright_yellow());
    println!("  {} - Clear conversation history", "/clear".bright_yellow());
    println!("  {} - Show conversation history", "/history".bright_yellow());
    println!("  {} - Show this help", "/help".bright_yellow());
    println!();
}

/// Save conversation to file.
fn save_conversation(history: &[ChatEntry], path: &str) -> Result<()> {
    use std::io::Write;

    let mut file = std::fs::File::create(path)?;

    for entry in history {
        writeln!(file, "{}: {}", entry.role, entry.content)?;
        writeln!(file)?;
    }

    Ok(())
}
